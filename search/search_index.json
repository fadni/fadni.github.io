{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome","title":"Welcome!","text":"<p>I am Khalid Elbadawi, an assistant professor at the faculty of Mathematical Sciences and Informatics, University of Khartoum.</p>"},{"location":"demo/","title":"Assignment","text":""},{"location":"demo/#q1","title":"Q1","text":"<p>Compute</p>  \\lim_{x\\to1+} \\frac{1-x^2}{x^2 -2x +1}"},{"location":"demo/#q2","title":"Q2","text":"<p>Compute the value a such that  f is continuous everywhere: </p>  f(t) =  \\begin{cases}     \\frac{\\sqrt{4+t^2} - 2}{t^2} &amp; t=0\\\\     a &amp; t \\neq 0 \\end{cases}"},{"location":"demo/#q3","title":"Q3","text":"<p>Compute the derivative of </p>  \\frac{\\sin x + x}{2 + \\cos x}"},{"location":"demo/#lecture-notes","title":"Lecture Notes","text":""},{"location":"demo/#derivative-formulas","title":"Derivative Formulas","text":"<p>Proof of (u+v)' = u' + v'</p> <p>Start by using the definition of the derivatives</p> \\begin{align*}     (u+v)'(x) &amp;= \\lim_{\\Delta x \\to 0} \\frac{(u+v)(x+\\Delta x) - (u+v)(x)}{\\Delta x} \\\\     &amp;= \\lim_{\\Delta x \\to 0} \\frac{u(x+\\Delta x)+v(x+\\Delta x) - u(x) - v(x)}{\\Delta x} \\\\     &amp;= \\lim_{\\Delta x \\to 0} \\Biggl \\{ \\frac{u(x+\\Delta x) -u(x)}{\\Delta x} + \\frac{v(x+\\Delta x) - v(x)}{\\Delta x} \\Biggr \\} \\\\     &amp;= u'(x) + v'(x)  \\; \\; \\; \\blacksquare \\end{align*} <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>This is without title line</p> <p>Lorem ipsum dolo sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Colored histogram (data is stored in cvs file)</p> <p>{     \"data\": {\"url\": \"https://raw.githubusercontent.com/fadni/data/main/gradesonly.csv\"},     \"transform\": [         {\"calculate\": \"datum['Final grade']\", \"as\":\"m\"},         {\"calculate\": \"upper(datum.m)=='ABS'?'ABS': datum.m&gt;=80? 'A+': datum.m&gt;=70?'A': datum.m&gt;=60?'B+': datum.m&gt;=50?'B': datum.m&gt;=40?'C': datum.m&gt;=30?'D': 'F'\", \"as\": \"Letter\"},         {\"filter\": \"datum.m\"}     ],     \"mark\": {\"type\":\"bar\", \"tooltip\":true},     \"encoding\": {         \"x\": {             \"field\": \"Letter\", \"type\": \"nominal\",             \"sort\": [\"A+\", \"A\", \"B+\", \"B\", \"C\", \"D\", \"F\", \"ABS\"]          },         \"y\": {\"aggregate\": \"count\"},         \"color\": {\"field\": \"Letter\"}     } }</p> <p>Here, data is hard coded </p> <p>{   \"description\": \"A simple bar chart with embedded data.\",   \"data\": {     \"values\": [       {\"a\": \"A\", \"b\": 28}, {\"a\": \"B\", \"b\": 55}, {\"a\": \"C\", \"b\": 43},       {\"a\": \"D\", \"b\": 91}, {\"a\": \"E\", \"b\": 81}, {\"a\": \"F\", \"b\": 53},       {\"a\": \"G\", \"b\": 19}, {\"a\": \"H\", \"b\": 87}, {\"a\": \"I\", \"b\": 52}     ]   },   \"mark\": {\"type\": \"bar\", \"tooltip\": true},   \"encoding\": {     \"x\": {\"field\": \"a\", \"type\": \"nominal\", \"axis\": {\"labelAngle\": 0}},     \"y\": {\"field\": \"b\", \"type\": \"quantitative\"}   } }</p>"},{"location":"courses/C2013/","title":"Programming Fundamentals (2)","text":""},{"location":"courses/C2013/#course-summary","title":"Course summary","text":"<p>This is the second part of programming fundamentals, a continuation of C1023 using C++ as the programming language. Principles of object oriented design including encapsulation, inheritance, polymorphism and the use of abstract classes will be introduced. Language features will also include pointers, dynamic memory allocation, operator overloading, some system calls and templates.</p>"},{"location":"courses/C2013/#textbooks-and-printed-resouces","title":"Textbooks and printed resouces","text":"<p> Absolute C++, Walter Savitch, Kenrick Mock, Addison Wesley 2012, 5th Edition</p>"},{"location":"courses/C2013/#prerequisites","title":"Prerequisites","text":"<ul> <li>C1023</li> </ul>"},{"location":"courses/C2013/#grading","title":"Grading","text":"Activity Weight Assignments 20% Labs 30% Midterm 10% Final Exam 40%"},{"location":"courses/C2013/lectures/lec011/","title":"Lecture 1: Review - Part 1","text":"<ul> <li>Reference: Starting out with C++ from Control Structure through Objects</li> <li>by Tonny Gaddis, </li> <li>10th Edition.</li> </ul>"},{"location":"courses/C2013/lectures/lec011/#overview-of-programming","title":"Overview of Programming","text":"<p>We start this review with a quote from very famous computer scientist:</p> <p>Programming is learned by writing programs</p> <p>Brian Kernighan</p> <p>Indeed! If you want to be professional in programming, then you must spend a lot of time (really a lot of time) writing several programs in front of a PC/laptop. Writing codes in a paper is not sufficient. You must write and run your programs. The purpose is to get familiar with programming environment and give you a feel of how you can get a computer to do things for you.</p> <p>Programming</p> <p>Programming is the activity of writing and testing programs</p> <p>The figure below shows a very basic view of the program development process. Generally, programming involves two activities: writing and testing. After designing your algorithm, you go through the following steps:</p> <pre><code>flowchart LR\n    S1[Edit] --&gt; S2[Compile] --&gt; C1{error?} -- No --&gt; S3[Run a test] --&gt; C2{Pass?} -- Yes --&gt; C3{Another test?} -- No --&gt; F(Done)\n    C1 -- Yes --&gt; S1\n    C2 -- No --&gt; S1\n    C3 -- Yes --&gt; S3</code></pre> <ol> <li>Edit your program and save it in a source file,</li> <li>Compile the source file to find any syntax error; if there is one, you return back to Step (1) to fix it. The compiler will emit an error message to guide you on how to fix the error. If the source file has compiled successfully, an executable file would be generated.</li> <li>Prepare a list of test cases to cover all execution paths to examine the logic of your algorithm.</li> <li>Pick one test case and run your program. If your program outputs unexpected result (i.e., the test case is failed), which indicates a logical error, then you need to go back to Step (1). Sometimes, you may need to return back to the very beginning and revise your algorithm.</li> <li>If your program passed all test cases, then you are done.</li> </ol>"},{"location":"courses/C2013/lectures/lec011/#debugging-and-ide","title":"Debugging and IDE","text":"<p>You, as a programmer, must test your program thoroughly, comparing the expected results to those that actually occur. When defects are found, they must be traced back to the source of the problem in the code/algorithm and corrected. The process of finding and correcting defects in a program is called debugging. Logical errors can manifest themselves in many ways, and the actual root cause might be difficult to discover.</p> <p>A software development environment is a set of tools used to create, compile, run, test, and modify a program. Some environments are referred to as integrated development environment (IDE) because they integrate various tools into one software program and provide a convenient graphical user interface (GUI). Most IDEs are shipped with a debugger tool, which helps you to debug your programs.</p> <p>Tip</p> <p>You must be familiar with this tool.</p>"},{"location":"courses/C2013/lectures/lec011/#semantics","title":"Semantics","text":"<p>One final remark before proceeding to the next section is that writing and debugging require you to be fully aware of statements\u2019 semantics.</p> <p>Semantics of a statement</p> <p>The semantics of a statement in a programming language define what will happen when that statement is executed</p> <p>Programming languages are generally unambiguous, which means the semantics of a program are well defined. That is, there is one and only one interpretation for each statement. For example, consider the highlighted line:</p> Example<pre><code>    int length ; // define a variable of type int\n    length = 99; // What is the semantics of this statement? (1)\n</code></pre> <ol> <li>Put 99 to the object named by <code>length</code>.</li> </ol> <p>Here, as the left\u2013hand side of the assignment statement, <code>length</code> means \"the object named by <code>length</code>,\" so that the assignment statement is read \"Put 99 into the object named by <code>length</code>.\"</p>"},{"location":"courses/C2013/lectures/lec011/#c-program-structure","title":"C++ Program Structure","text":"A typical C++ program<pre><code>// this program outputs the message \" Hello World !\" to the monitor\n# include &lt;iostream&gt;\n\nusing namespace std;\n\n// MAIN function\nint main ()\n{\n    cout &lt;&lt; \" Hello World !\" &lt;&lt; endl ;\n\n    return 0;\n}\n</code></pre> <p>Exercises</p> QuestionsAnswer <ol> <li>Why are the following not comments? <pre><code>(a) /*/\n(b) /* comment? * /\n(c) // Is this\n    a comment?\n</code></pre></li> <li>What is the difference between: <pre><code>(a) #include &lt;iostream&gt;\n(b) #include &lt;iostream.h&gt;\n</code></pre></li> <li>What is the difference between: <pre><code>(a) #include &lt;string.h&gt;\n(b) #include &lt;cstring&gt;\n(c) #include &lt;string&gt;\n</code></pre></li> <li>Correct the following code without using the keywords <code>using</code> and <code>namespace</code>: <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    cout &gt;&gt; \"Hello World!\" &gt;&gt; endl;\n\n    return 0;\n}\n</code></pre></li> </ol> <ol> <li> <p>(a) It should be either <code>//</code> or <code>/* */</code>. (b) There should be no space between <code>*</code> and <code>/</code> at the end. (c) <code>//</code> is a line comment. So, the second line should also begin with <code>//</code></p> </li> <li> <p>No difference. <code>&lt;iostream.h&gt;</code> is an older header file corresponding to the new header file <code>&lt;iostream&gt;</code>.</p> </li> <li> <p>(a) This is the old header name for <code>&lt;cstring&gt;</code>.      (b) This is to include C-style string library.      (c) This is to include C++ string library.</p> </li> <li>The corrected code is:     <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    std.cout &gt;&gt; \"Hello World!\" &gt;&gt; std.endl;\n\n    return 0;\n}\n</code></pre></li> </ol>"},{"location":"courses/C2013/lectures/lec011/#data-types-and-expressions","title":"Data Types and Expressions","text":"<p>Recall the following. It is important to understand and remember each definition</p> <p>Definitions</p> <ul> <li>A type defines a set of possible values and a set of operations defined on them.</li> <li>An object is some memory that holds a value.</li> <li>A value is a set of bits in memory interpreted according to a type.</li> <li>A variable is a named object.</li> <li>A declaration is a statement that gives a name to an object along with a type.</li> <li>A definition is a declaration that sets aside memory for an object.</li> </ul>"},{"location":"courses/C2013/lectures/lec011/#examples","title":"Examples","text":"<p>What is the semantics of:</p> <pre><code>int length = 100;\n</code></pre> <p> </p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte memory. (1)</li> <li>The new object will be named <code>length</code>.</li> <li>The data type of <code>length</code> is <code>int</code>.</li> <li>The object will be initialized with the value of 100.</li> </ol> <ol> <li>I am assuming the size of <code>int</code> is 4 bytes</li> </ol> <p>Be aware of the highlighted text above. The object will be initialized, not assigned.</p> <p>What is the semantics of:</p> <p><pre><code>length = 99;\n</code></pre> This is an assignment statement. It means to put/assign the value 99 into/to the object named by <code>length</code>.</p> <p>What is the semantics of:</p> <pre><code>int &amp;side = length;\n</code></pre> <p></p> <p>Semantically, this is a declaration statement. It means as follows. The object named by <code>length</code> has a new (another) name, which is <code>side</code>, as shown. Consequently, we have ONE object that can be referenced by two names: <code>side</code> and <code>length</code>.</p> <p>What is the semantics of:</p> <pre><code>int side = length;\n</code></pre> <p></p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte memory.</li> <li>The new object will be named <code>side</code>.</li> <li>The data type of <code>side</code> is <code>int</code>.</li> <li>The object will be initialized with the value of <code>length</code>.</li> </ol> <p>Exercise</p> QuestionAnswer <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int length = 10;\n    int &amp;side = length;\n    int width = side;\n    int total = 2 * width;\n\n    side = side / 4;\n    width = width + 1;\n    total = total - 5;\n    cout &lt;&lt; \"length = \" &lt;&lt; length &lt;&lt; endl;\n    cout &lt;&lt; \"side = \" &lt;&lt; side &lt;&lt; endl; \n    cout &lt;&lt; \"width = \" &lt;&lt; width &lt;&lt; endl; \n    cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl; \n\n    return 0;\n}\n</code></pre></p> <p>The output is</p> <pre><code>length = 2\nside = 2\nwidth = 11\ntotal = 15\n</code></pre>"},{"location":"courses/C2013/lectures/lec011/#data-types","title":"Data Types","text":"<ol> <li>Built-in data types:<ol> <li>Ordinal types: <code>int</code>, <code>char</code>.<ul> <li>C++11 signed integer types: <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>.</li> <li>C++11 unsigned integer types: <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code>.</li> </ul> </li> <li>Boolean type: <code>bool</code>.</li> <li>Floating-point types: <code>float</code>, <code>double</code>.</li> <li>String type: <code>string</code></li> </ol> </li> <li>Type modifiers:<ol> <li>Sign modifiers (for ordinal types): <code>signed</code>, <code>unsigned</code>.</li> <li>Size modifiers: <code>short</code>, <code>long</code>, <code>long long</code>.</li> <li>Storage modifiers: <code>static</code>, <code>const</code>, <code>auto</code></li> </ol> </li> <li>Type specifier: <code>auto</code></li> </ol>"},{"location":"courses/C2013/lectures/lec011/#constants-and-literals","title":"Constants and Literals","text":"<ol> <li> <p>Integer constants: </p> <ul> <li>Decimal constants (<code>int</code>): <code>3</code>, <code>-40</code> or <code>12024</code></li> <li>Binary constants (<code>int</code>): <code>0b101001011</code> or <code>0b1010'0111</code></li> <li>Octal constants (<code>int</code>): <code>023</code></li> <li>Hexadecimal constants (<code>int</code>): <code>0x1A</code> or <code>0x1a</code></li> <li>Unsigned constants: <code>123u</code>, <code>123U</code>, or <code>0xFFFFu</code></li> <li>Long constants: <code>123l</code>, <code>123L</code> or <code>0xFFFFL</code></li> <li>Unsigned long constants: <code>123ul</code>, <code>123UL</code> or <code>0xFFFFUL</code> </li> </ul> </li> <li> <p>Character constants (type is <code>char</code>)</p> <ul> <li>Letters: <code>'a'</code>, <code>'B'</code>, <code>'+'</code> or <code>' '</code></li> <li>Escape sequence: <code>'\\t'</code>, <code>'\\r'</code>, <code>'\\n'</code>, <code>'\\0'</code>, <code>'\\x20'</code> or <code>\\101</code></li> </ul> </li> <li>Floating-point constants: <code>1.2</code>, <code>2.001</code>, <code>-0.0234</code>, <code>9e-5</code> or <code>-2.34E3</code><ul> <li>No suffix defines <code>double</code></li> <li><code>f</code> or <code>F</code> defines  <code>float</code></li> <li><code>l</code> or <code>L</code> defines <code>long double</code></li> </ul> </li> <li>Boolean constants: <code>true</code>, <code>false</code>.</li> <li>Recall that literals are named constant<ol> <li>Example (1): <code>const int LENSIZE = 10;</code> Here <code>LENSIZE</code> is a constant integer with value <code>10</code>.</li> <li>Example (2): <code>constexpr double PI = 3.14159;</code></li> </ol> </li> </ol>"},{"location":"courses/C2013/lectures/lec011/#expressions","title":"Expressions","text":"<ul> <li>The most basic building block of programs.</li> <li>An expression can be:<ol> <li>a constant,</li> <li>a variable (must have a value),</li> <li>a function call, </li> <li>an arithmetic operation, or</li> <li>a logical operation that evaluates to TRUE or FALSE</li> </ol> </li> <li>The type of an expression is the type of its value</li> </ul> <p>What is an operation?</p> <p>An operation is composed of a set of operands and a set of operators. The operation is parsed according to the operator(s) priority and associativity. Each operand by itself is an expression.</p> <p>The expression <code>std::cout &lt;&lt; a &amp; b</code> is parsed as <code>( (std::cout &lt;&lt; a) &amp; b)</code>, and not as  <code>( std::cout &lt;&lt; (a &amp; b) )</code></p> <p>Example 1</p> <p>Consider the following expression: <code>10 + 2 / 4</code>. Simply, this expression consists of three operands (<code>10</code>, <code>2</code>, and <code>4</code>) and two operators (<code>+</code> and <code>/</code>). It will be parsed (eventually, evaluated) as follows:</p>  \\begin{align*}     10 ~~+~~ 2 ~~/~~ 4 &amp;= 10 ~~+~~ \\underbrace{2 ~~/~~ 4}_\\text{(1)} \\\\     &amp;= 10 ~~+~~ 0 \\\\     &amp;= \\underbrace{10 ~~+~~ 0}_\\text{(2)} \\\\     &amp;= 10  \\end{align*}   <p>Example 2</p> <p>In these examples, we will revise the principle of associativity.</p> <p>Consider the following expression: <code>10 / 2 / 4</code></p>  \\begin{align*}     10 ~~/~~ 2 ~~/~~ 4 &amp;= \\underbrace{10 ~~/~~ 2}_\\text{(1)} ~~/~~ 4 \\\\     &amp;= 5 ~~/~~ 4 \\\\     &amp;= \\underbrace{5 ~~/~~ 4}_\\text{(2)} \\\\     &amp;= 1  \\end{align*}   <p>Consider the following expression: <code>x = y = 10</code></p>  \\begin{align*}     x ~~=~~ y ~~=~~ 10 &amp;\\rightarrow x ~~=~~ \\underbrace{y ~~=~~ 10}_\\text{(1)} \\\\     &amp;\\rightarrow x ~~=~~ 10 \\\\     &amp;\\rightarrow \\underbrace{x ~~=~~ 10}_\\text{(2)} \\\\     &amp;\\rightarrow 10 \\end{align*}   <p>The following table shows the precedence and associativity of C++ operators (from highest to lowest precedence). Operators with the same precedence number have equal precedence unless another relationship is explicitly forced by parentheses.</p> Group Description Operator Group 1: no associativity scope resolution <code>::</code> Group 2: Naturally left to right associativity Array subscript <code>[]</code> Function call <code>()</code> Postfix increment (i.e., <code>a++</code>) <code>++</code> Postfix decrement (i.e., <code>a--</code>) <code>--</code> Type name <code>typeid</code> Constant type conversion <code>const_cast</code> Dynamic type conversion <code>dynamic_cast</code> Reinterpreted type conversion <code>reinterpret_cast</code> Static type conversion <code>static_cast</code> Group 3: Naturally right to left associativity Size of object or type <code>sizeof</code> Prefix increment (i.e., <code>++a</code>) <code>++</code> Prefix decrement (i.e., <code>--a</code>) <code>--</code> One's complement or bitwise NOT <code>~</code> Logical NOT <code>!</code> Unary negation <code>-</code> Unary plus <code>+</code> Address of <code>&amp;</code> Indirection (dereference) <code>*</code> Create object <code>new</code> <code>new[]</code> Destroy object <code>delete</code> <code>delete[]</code> C-style cast <code>()</code> Group 4: left to right associativity Pointer-to-member (objects or pointers) <code>.*</code> <code>-&gt;*</code> Group 5: left to right associativity Multiplication <code>*</code> Division <code>/</code> Modulus <code>%</code> Group 6: left to right associativity Addition <code>+</code> Subtraction <code>-</code> Group 7: left to right associativity Left shift <code>&lt;&lt;</code> Right shift <code>&gt;&gt;</code> Group 8: left to right associativity Less than <code>&lt;</code> Greater than <code>&gt;</code> Less than or equal to <code>&lt;=</code> Greater than or equal to <code>&gt;=</code> Group 9: left to right associativity Equality <code>==</code> Inequality <code>!=</code> Group 10: left to right associativity Bitwise AND <code>&amp;</code> Group 11: left to right associativity Bitwise XOR (exclusive OR) <code>^</code> Group 12: left to right associativity Bitwise OR  (inclusive OR) <code>|</code> Group 13: left to right associativity Logical AND <code>&amp;&amp;</code> Group 14: left to right associativity Logical OR <code>||</code> Group 15: right to left associativity Conditional <code>?:</code> Assignment <code>=</code> Multiplication assignment <code>*=</code> Division assignment <code>/=</code> Modulus assignment <code>%=</code> Addition assignment <code>+=</code> Subtraction assignment <code>-=</code> Left-shift assginment <code>&lt;&lt;=</code> Right-shift assignment <code>&gt;&gt;=</code> Bitwise AND assignment <code>&amp;=</code> Bitwise inclusive OR assignment <code>|=</code> Bitwise exclusive OR assignment <code>^=</code> throw expression <code>throw</code> Group 16: left to right associativity Comma <code>,</code> <p>Order of evaluation</p> <p>Consider the following expression <code>a() + b() / c()</code></p> <p>During the compile-time, <code>a()</code> will be parsed as function call. Then, <code>b()</code> will be parsed as function call. Then <code>c()</code> is parsed as function call. Then, division is parsed. Finally addition is parsed. So, the compiler will produce <code>(call(a) + ( call(b) / call(c) ) )</code>.</p> <p>During the run-time, the order of function calls, <code>call(b)</code> and <code>call(c)</code>, is undetermined.  <code>call(c)</code> may be evaluated first or second. So, the order of evaluation of function calls can be:</p> <ol> <li><code>call(b)</code> \\rightarrow <code>call(c)</code> \\rightarrow <code>call(a)</code>, OR</li> <li><code>call(c)</code> \\rightarrow <code>call(b)</code> \\rightarrow <code>call(a)</code>.</li> </ol> <p>Exercises</p> QuestionsAnswers <ol> <li> <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\nint main() {\n    int i = 100;\n\n    i = i+i;\n    i = 2*i;\n    std::cout &lt;&lt; i+i &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p> </li> <li> <p>What is the output of the following program?</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () \n{ \n    int Ifive = 5; \n    int Isix = 6; \n    double Dfive = 5.0; \n    double Dsix = 6.0;\n\n    cout &lt;&lt; Ifive / Isix &lt;&lt; endl; \n    cout &lt;&lt; Dfive / Dsix &lt;&lt; endl;\n    cout &lt;&lt; Ifive / Dsix &lt;&lt; endl;\n    cout &lt;&lt; Dfive / Isix &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> </li> <li> <p>The following fragment purports to convert from degrees Celsius to degrees Fahrenheit. However, it has an error. Fix the code. <pre><code>double c = 20;\ndouble f;\n\nf = (9/5) * c + 32.0;\ncout &lt;&lt; c &lt;&lt; \"C is equivalent to \" &lt;&lt; f &lt;&lt; \"F.\" &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>Find the syntax errors in the following program and fix them, so that the program runs and displays <code>Nice</code>. <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int j = 4.5;\n    unsigned float i = 1.23;\n    double j = 6.7;\n\n    k = 10;\n    cout &lt;&lt; \"Nice &lt;&lt; '\\n';\n    return 5;\n}\n</code></pre></p> </li> <li> <p>Is there an error in the following code segment? (What kind? syntactic or semantic), assume <code>x</code> is declared as <code>int</code>: <pre><code>// check if x between 1 and 10\nif (1 &lt;= x &lt;= 10)\n    cout &lt;&lt; \"Correct\" &lt;&lt; endl;\nelse\n    cout &lt;&lt; \"Incorrect\" &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\nint main() \n{\n    int k;\n    float i = 3.9, j = 1.2;\n\n    k = i + (int)j;\n    std::cout &lt;&lt; k - (int)((int)i + j) &lt;&lt; '\\n';\n    return 0;   \n}\n</code></pre></p> </li> <li> <p>The following program reads three integers and displays their average. Is it written correctly? <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() \n{\n    int i, j, k;\n\n    cout &lt;&lt; \"Enter three integers: \";\n    cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;\n    cout &lt;&lt; fixed &lt;&lt; \"Avg: \" &lt;&lt; i+j+k / 3 &lt;&lt; endl;\n    return 0;       \n}\n</code></pre></p> </li> <li> <p>What is the output of the following program? Note: There is no syntactic error.     <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int a = 4, b = 6, c;\n    a = (a &lt;= (b-2)) + (b &gt; (a+1));\n    b = (a == 2) &gt; ((b-3) &lt; 3);\n    c = (b != 0);\n    std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p> </li> </ol> <ol> <li>Check the answer by yourself (write and run)</li> <li>Write and run the code</li> <li>There is a logical error at <code>9/5</code>, which always produces integer <code>1</code>. The code should be     <pre><code>double c = 20;\ndouble f;\n\nf = (9.0/5) * c + 32.0;\ncout &lt;&lt; c &lt;&lt; \"C is equivalent to \" &lt;&lt; f &lt;&lt; \"F.\" &lt;&lt; endl;\n</code></pre></li> <li> <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    float i = 1.23;\n    double j = 6.7;\n\n    int k = 10;\n    std::cout &lt;&lt; \"Nice &lt;&lt; '\\n';\n    return 5;\n}\n</code></pre> </li> <li> <p>Yes!. There is a semantic error. The conditional expression will be parsed as <code>( (1 &lt;= x) &lt;= 10)</code>. Regardless of the value of <code>x</code>, the conditional expression is always TRUE. The correct way to express that x between 1 and 10 is</p> <pre><code>if ((1 &lt;= x) &amp;&amp; (x &lt;= 10))\n    cout &lt;&lt; \"Correct\" &lt;&lt; endl;\nelse\n    cout &lt;&lt; \"Incorrect\" &lt;&lt; endl;\n</code></pre> </li> <li> <p>Write and run by yourself</p> </li> <li>No, there is a logical error. The expression <code>i+j+k / 3</code> will be parsed as <code>( (i + j) + (k / 3) ). So the last</code>cout` should be:     <pre><code>cout &lt;&lt; fixed &lt;&lt; \"Avg: &lt;&lt; (i + j + k)/3 &lt;&lt; endl;\n</code></pre></li> <li>Write and run by yourself</li> </ol>"},{"location":"courses/C2013/lectures/lec011/#scope-and-lifetime","title":"Scope and Lifetime","text":"<p>In a nutshell, the term scope is associated with variables, while lifetime (sometimes we say storage duration) is associated with objects. A variable could have a local scope or global scope. Similarly, an object could have a local lifetime or global lifetime. Consider the following illustrative example:</p> <pre><code>    int days;\n\n    int main() \n    {\n        int week = 1;\n        .\n        .\n    }\n\n    void myfunc (int t)\n    {\n        int month;\n        static int next = 0;\n        .\n        .\n    }\n</code></pre> <ol> <li>The variable <code>days</code> has a global scope. So, the name is visible from line 1 up to line 16.</li> <li>The object referenced by <code>days</code> has a global lifetime. So, the object's life starts when the program starts executing and ends when the program terminates. In other words, the object will be created (or constructed) when the program starts and destroyed when the program terminates.</li> <li>The variable <code>week</code> is visible only within its block (i.e., from line 5 up to line 8). The life of the object referenced by <code>week</code> starts when the program executes line 5 and ends when the execution reaches line 8.</li> <li>The variable <code>t</code> is visible within the function block (i.e., from line 11 up to line 16). The life of the object referenced by <code>t</code> starts whenever the program invokes the function <code>myfunc</code> and ends when the function returns.</li> <li>The variable <code>month</code> is visible only within its block (i.e., from line 12 up to line 16). The life of the object referenced by <code>month</code> starts whenever the program executes line 12 and ends when the function returns.</li> <li>The variable <code>next</code> has a local scope (i.e., it's visible from line 13 up to line 16). However, the object referenced by <code>next</code> has a global lifetime, due to the keyword <code>static</code>. This implies that the object will be created ONLY ONCE, when the program executes the function for the first time. The object will be destroyed when the program terminates.</li> </ol> <p>Exercise</p> QuestionAnswer <p>What is the output of the following program?</p> <pre><code>    #include &lt;iostream&gt;\n    using namespace std;\n    void myfunc () {\n        int x = 5;\n        static int y = 5;\n\n        cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;\n        x = x + 1;\n        y = y + 1;\n        return;\n    }\n    int main()\n    {\n        myfunc();       // first call\n        myfunc();       // second call\n        myfunc();       // third call\n    }\n</code></pre> Output<pre><code>    x = 5, y = 5\n    x = 5, y = 6\n    x = 5, y = 7    \n</code></pre>"},{"location":"courses/C2013/lectures/lec011/#lvalue-and-rvalue","title":"Lvalue and Rvalue","text":"<p>One of the fundamental C++ concepts is the concept of value category, which we are going to explain it very briefly.</p> <p>Every C++ expression has a type, and belongs to a value category. The value categories are the basis for rules that compilers must follow when creating, copying, and moving temporary objects during expression evaluation.</p> <p>In this course, we focuses on two value categories: Lvalue and Rvalue.</p> <ul> <li>Lvalue is an expression whose evaluation determines the identity of an object</li> <li>Rvalue is an expression whose evaluation:<ul> <li>computes the value of an operand of a built-in operator (such rvalue has no result object), or</li> <li>initializes an object (such rvalue is said to have a result object).</li> </ul> </li> </ul> <p></p> <p>Let us consider the variable <code>length</code> that contains the value <code>99</code> as shown in the figure. The lvalue of <code>length</code> represents the object itself or its memory location, while the rvalue of <code>length</code> represents its content or its value.</p> <p>Assignment statement</p> <p>The left-hande side of an assignment is always treated as lvalue and the right-hand side is treated as rvalue.</p> <p>Example</p> <pre><code>    x = y;\n</code></pre> <ul> <li>The right-hand expression, which is <code>y</code>, will be treated as rvalue. The left-hand expression, which is <code>x</code>, will be treated as lvalue. </li> <li>The rvalue of <code>y</code> is its content (or the value of <code>y</code>). The lvalue of <code>x</code> is its memory location or the object referenced by <code>x</code>.</li> <li>Consequently, the meaning (or semantics) of this statement is as follows: Put the value of <code>y</code> into the object named by <code>x</code>.</li> </ul> <p>Example</p> <pre><code>    x + 1 = y;\n</code></pre> <p>If you try to compile the above statement, the compiler will throw an error message: </p> <p><code>lvalue required as left operand of assignment.</code></p> <p>Because the expression <code>x + 1</code> can't be an lvalue. No memory location associated with this expression. </p> <p>Example</p> <pre><code>    ((x &lt; 5)? x : y) = 10;\n</code></pre> <p>The left-hand side, which is the conditional operator, is a valid lvalue expression, since its lvalue is either the memory location of <code>x</code> or the memory location of <code>y</code>. The right-hand side, which is <code>10</code>, is a valid rvalue. The conditional operator has the inner expression <code>(x &lt; 5)</code>, where <code>x</code> will be treated as rvalue. Therefore, the semantics is as follows. If the value of <code>x</code> is less than <code>5</code>, put the value <code>10</code> into <code>x</code>. Otherwise, put the value <code>10</code> into <code>y</code>.</p>"},{"location":"courses/C2013/lectures/lec011/#initialization-and-assignment","title":"Initialization and Assignment","text":"<p>You need to distinguish two similar, but logically distinct, operations:</p> <ul> <li>Initialization (giving a variable its initial value at the time of construction)</li> <li>Assignment (giving a variable a new value)</li> </ul> <p>These operations are so similar that C++ allows us to use the same notation (the <code>=</code> operator) for both. </p> <p>Let us consider the following code: <pre><code>    int length = 99;        // definition statement\n    int width;\n\n    width = 10;             // assignment statement\n</code></pre></p> <p>There is no doubt that the operator <code>=</code>, in line 4, is the assignment operator. It puts the value 10 into the object named by <code>width</code>. However, the operator <code>=</code>, in line 1, is NOT the assignment operator. The form <code>= 99</code> is known as an initializer. It means that as part of constructing the object named by <code>length</code>, the value <code>99</code> will be inserted, such that after the construction finishes, the variable <code>length</code> will have the initial value <code>99</code>. </p> <p>In C++, the initializer may be one of the following forms:</p> <ol> <li><code>(</code> expression-list <code>)</code></li> <li><code>=</code> expression</li> <li><code>{</code> initializer-list <code>}</code></li> <li><code>{</code> designated-initializer-list<code>}</code></li> </ol> <p>Therefore, initialization can be written as follows:</p> <ul> <li><code>int length = 99; // using the second form</code> or</li> <li><code>int length (99); // using the first form</code> or</li> <li><code>int length {99}; // using the third form</code></li> </ul> <p>Important</p> <p>The initialization operation occurs at the time of object's construction. It also takes place during function calls: when passing arguments and when the function returns values.</p> <p>Exercises</p> QuestionsAnswers <ol> <li> <p>Write a program that declares two floating-point variables (e.g., <code>a</code>, <code>b</code>), assigns to them two positive values (e.g., <code>3.45</code> and <code>6.78</code>) and swaps their integer parts (i.e., <code>a</code> becomes <code>6.45</code> and <code>b</code> becomes <code>3.78</code>). For casting, use the <code>static_cast&lt;&gt;</code> operator.</p> </li> <li> <p>Write a program that reads three integers, stores them in three variables, and rotates them one place right. For example, if the user enters the numbers <code>1</code>, <code>2</code>, and <code>3</code> and they are stored in variables <code>a1</code>, <code>a2</code> and <code>a3</code>, the program should rotate their values one place right, so that <code>a1</code> becomes <code>3</code>, <code>a2</code> becomes <code>1</code>, and <code>a3</code> becomes <code>2</code>.</p> </li> <li> <p>Write a program that reads a three-digit positive integer, makes its hundreds ones and vice versa and displays the new number. For example, if the user enters <code>123</code>, the program should display <code>321</code>. Use only one variable.</p> </li> <li> <p>Write a program that reads a positive integer and rounds it up or down to its nearest tens. For example, if the user enters <code>13</code>, the program should display <code>10</code>. if the input number is <code>6</code>, the program should display <code>10</code>, while if it is <code>255</code>, the program should display <code>260</code>. For casting, use the <code>static_cast&lt;&gt;</code> operator.</p> </li> </ol> <ol> <li> <p></p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    float a = 3.45, b = 6.78;\n    double dec;\n\n    int temp = static_cast&lt;int&gt;(a); // store integer part of a\n    dec = a - static_cast&lt;int&gt;(a);  // decimal part of a\n    a = static_cast&lt;int&gt;(b) + dec;\n    dec = b - static_cast&lt;int&gt;(b);  // decimal part of b\n    b = temp + dec;\n\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> </li> <li> <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    int a1, a2, a3;\n\n    std::cout &lt;&lt; \"Enter three integers (a1, a2 and a3): \";\n    std::cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3;\n\n    int temp = a3;\n    a3 = a2;\n    a2 = a1;\n    a1 = temp;\n\n    std::cout &lt;&lt; \"a1 = \" &lt;&lt; a1 &lt;&lt; \", a2 = \" &lt;&lt; a2 &lt;&lt; \", a3 = \" &lt;&lt; a3 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> </li> <li> <pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\nint main()\n{\n    int n;\n\n    cout &lt;&lt; \"Enter three-digit positive integer: \";\n    cin &gt;&gt; n;\n\n    n = n/100 + ((n/10) % 10)*10 + (n%10)*100;\n\n    cout &lt;&lt; \"The output is \" &lt;&lt; n &lt;&lt; endl;\n    return 0;\n}\n</code></pre> </li> <li> <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    int n;\n    std::cout &lt;&lt; \"Enter postive number: \";\n    std::cin &gt;&gt; n;\n\n    float m = (n + 5) / 10.0;\n    n = static_cast&lt;int&gt;(m) * 10;\n\n    std::cout &lt;&lt; \"The number after rounding to nearest 10: \" &lt;&lt; n &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> </li> </ol>"},{"location":"courses/C2013/lectures/lec012/","title":"Lecture 1: Review - Part 2","text":""},{"location":"courses/CS425/","title":"Parallel Computing","text":""},{"location":"courses/CS425/#course-summary","title":"Course summary","text":""},{"location":"courses/CS425/#textbooks-and-printed-resouces","title":"Textbooks and printed resouces","text":""},{"location":"courses/CS425/#prerequisites","title":"Prerequisites","text":"<ul> <li>C2023</li> </ul>"},{"location":"courses/CS425/#grading","title":"Grading","text":"Activity Weight Assignments 20% Labs 30% Midterm 10% Final Exam 40%"}]}